{"name":"Dag-runner","tagline":"Execute functions specified by a DAG (directed acyclic graph) ","body":"# DAG-Runner\r\n\r\nLife is too short to be wasted on piping the output of one function\r\ninto the other. Concentrate on writing (awesome) functions and let\r\ndag-runner do the (dirty) work of constructing the function execution\r\nflow.\r\n\r\nYes, this is a Clojure library designed to execute functions that\r\ndependend upon the output of each other as specified by a DAG\r\n(directed acyclic graph).\r\n\r\n![](images/example-dag-runner.png)\r\n\r\n## Installation \r\n\r\nLeiningen coordinates: \r\n```clj\r\n[dag-runner \"0.1.0-SNAPSHOT\"]\r\n``` \r\n\r\nFor Maven users: \r\n\r\n``` xml \r\n<dependency>\r\n  <groupId>dag-runner</groupId>\r\n  <artifactId>dag-runner</artifactId>\r\n  <version>0.1.0-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n\r\n## Usage\r\n\r\nFirst prepare a bunch of awesome functions. The input argument of each\r\nfunction in the flow should be taking key-value pairs and the output\r\nshould also be hash-maps. For example: \r\n\r\nHere we would like to run through three functions with to get the\r\nultimate output. \r\n\r\n```clj\r\n(defn funA [{:keys [x y]}]\r\n  {:z (+ x y)\r\n   :w (- x y)})\r\n\r\n(defn funB\r\n  \"this function would take :w of the output from funA.\"\r\n  [{:keys [w a]}]\r\n  {:b (* w a)})\r\n\r\n(defn funC\r\n  \"this function would take :z from funA and :b from funB and the\r\n  output :u :v are the ultimate output that we care about.\"\r\n  [{:keys [b z]}]\r\n  {:u (* b z)\r\n   :v (- b z)}\r\n  )\r\n```\r\nThe topology of the above function flow can be visualized as: \r\n\r\n![](images/example-diagram.png)\r\n\r\nThe function `dag-run` will create a super function `aggregated-fun`\r\n(or any name you like) that takes all necessary inputs for the above\r\nflow (`:x :y :a`), automatically run through all functions above, and\r\ngenerate the ultimate output (`:u :v`).\r\n\r\n```clj\r\n(use 'dag-runner.core)\r\n\r\n(dag-run aggregated-fun\r\n         [{:function funA :input [:x :y] :output [:z :w]}\r\n          {:function funB :input [:w :a] :output [:b]}\r\n          {:function funC :input [:b :z] :output [:u :v]}])\r\n\r\n(aggregated-fun :x 1 :y 2 :a 3)\r\n;; {:u -9, :v -6}\r\n```\r\n\r\n## ToDo\r\n\r\n* Add parser layer to directly take input and output key from function\r\n  definitions. \r\n* Add safeguard layer to make sure that the flow can finish.\r\n\r\n## License\r\n\r\nCopyright [Hesen Peng] [1] Â© 2014 \r\n\r\nDistributed under the Eclipse Public License either version 1.0 or (at\r\nyour option) any later version.\r\n\r\n[1]: www.linkedin.com/in/hesenpeng/","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}